---
title: TIL 2025/11/13 - this 바인딩
date: 2025-11-13 15:00:00 +0900
categories: [TIL, JS]
tags: [js]
---

## TIL을 시작하며
나는 현재 `HTML`, `CSS`, `JS`의 기초를 온라인 강의를 통해 공부했다. 지금까지는 단순히 강의를 들으며 만든 결과물(숙제, 포트폴리오 실습)들을 비공개로 Github에 백업하기만 했다. 문제는 남는 것이 없다는 것이다. 최대한 정답지를 보지 않고 몇시간 씩 고민해가며 결과물을 완성하긴 했지만, 저 결과물들을 Github에 올려두는 것만으로는 아무도 알아주지 않는다. 사실 해설 강의를 보고 따라치기만 해도 만들 수 있는 것들이기 때문이다. 그래서 이제부턴 내가 배운 것들을 정리하고 기록하고자 TIL 포스팅을 시작하기로 했다.

이 포스팅을 시작한 또 다른 이유는 나는 더 이상 기초 문법 수준에 머무를 수 없다고 느꼈기 때문이다. 지금 나는 Findit 프로젝트를 진행하고 있는데, 생각보다 기초 문법을 아는 것만으론 할수 없는게 많다는 것을 깨달았다. 생각해보면 당연한 이야기이다. 실제 프로젝트의 코드들을 살펴보면 아직 배우지 못한 `this`, `new`, `async`와 `await` 같은 키워드들이 즐비할 뿐더러, 편리한 개발을 위해 만들어진 다양한 라이브러리와 프레임워크를 사용할 때마저 이러한 키워드들이 필수적으로 사용된다. 그리고 나는 `prototype`, `getter`, `setter`와 같은 객체지향과 관련한 개념은 아예 감도 잡지 못했다. 그래서 본격적으로 `React`와 `Next.js`를 공부하기 전에 JS 심화 강의를 듣기로 했고, 중고등학교 시절 개념을 노트에 정리해가며 공부했듯 이젠 TIL 포스팅을 통해 배운 것들을 정리해가며 공부하고자 한다.


## Today I Learned
### `this` 키워드
나에게 `this` 키워드는 일종의 만능 키워드라고 생각한다. 내가 지금까지 배운 수준에서 `this`는 이벤트리스너에서 이벤트가 일어난 HTML 요소를 선택하고 싶을 때 사용하는 `event.currentTarget`을 `this`로 치환하여 사용하기도 하고, 객체 내의 다른 프로퍼티들을 선택하고자 할 때 `this` 키워드를 사용하기도 하였다. 만능이라는 것은 기능이 많다는 뜻이지만, 그만큼 그 실체를 어떠한 개념으로 딱 집어 정의하기 어렵다는 뜻이기도 하다. 

자바스크립트의 심화 문법들과 객체지향을 설명하는 강의를 결제한 김에, 내 머릿속에 뒤죽박죽이던 개념들 중 하나였던 `this`를 정리해보기로 한다. 

#### 1. 일반 함수로서 호출 - `window` 전역 객체
```js
function foo(){ console.log(this); }
foo();                  // Window {...}
```
`()`를 이용해 일반 함수로서 호출된 함수의 경우 `this`는 `Window {...}` 객체로 바인딩된다. 위 예제에서 역시 `foo()` 일반 함수로 호출하였기에 `this`는 `window` 객체에 바인딩된다. 

다만, `'use strict'` 엄격 모드를 사용하는 경우에 `this`는 `undefined`가 된다. 이는 `this`를 사용하면서 `window` 객체를 오염시키는 것을 막기 위함이라고 한다.

> **`window` 객체란?**
> > 모든 전역 변수, 함수, DOM을 저장하고 관리하는 전역 객체.
>
> 라고 하는데, 쉽게 말하자면 
> 1. `document.getElementById()`, `console.log()`와 같은 함수들을 포함하고, 
> 2. 내가 선언한 전역변수들을 보관하며,
> 3. HTML 요소들을 저장하는 DOM을 보관하는 
> 
> 모든 것을 담아내는 큰 객체라는 뜻이다.
>
>즉 위 예제에서 `foo()`라는 함수는 사실 `window.foo()`로도 동일하게 호출할 수 있다. (`var`나 `function` 선언에 한하여)
>(다만 브라우저 환경에서만 `window` 객체가 존재하고, `node.js` 환경에서는 `global` 객체가 대신한다고 한다.)
{: .prompt-info}

#### 2. 메소드 호출 - 메소드가 포함된 상위 객체
```js
const person = {
    name: 'Kim',
    hi: function(){
        console.log(this);
        console.log('Hi,', this.name);
    }
};
person.hi();    // person {name: 'Kim', hi: f}
                // 'Hi, Kim'
```
어떠한 객체에 포함된 함수인 메소드(method)의 경우엔 이 메소드가 포함된 상위 객체가 `this`와 바인딩된다. 위 예제에서 `hi`는 `person`이라는 객체에 포함된 메소드이다. 그래서 `this`는 `person` 객체를 의미하게 된다.

> ~~1번 규칙은 2번 규칙의 연장선 상에 놓여 있다고 볼 수 있다. 일반 함수 호출은 전역 스코프에서 이루어지므로, 해당 함수의 상위 객체가 `window` 객체이기 때문이다.~~
{: .prompt-info}

> 위 설명은 흔한 오해라고 한다. 일반 함수 호출은 `window.foo()` 식의 메소드 호출로 동작하는 것이 아니라, 다른 바인딩 규칙(메소드, `new` 등)이 적용되지 않았을 때의 **기본 규칙(Default Binding)**으로 `this`가 `window`가 되는 것이라고 한다.
{: .prompt-danger}

```js
const obj1 = {
    obj2: {
        foo: function(){ 
            console.log(this);
        }
    }
};
obj1.obj2.foo()    // {foo: f} (== obj2)
```
중첩되어 있는 객체의 경우에도, `this`는 해당 메소드가 포함된 바로 상위의 객체를 의미하게 된다. 따라서 위 예제에서 `foo` 메소드에서의 `this`는 `obj2`에 바인딩된다. 


```js
const person = {
    name: 'Kim',
    foo: function(){
        console.log(this);
    }
};
person.foo();    // person {name: 'Kim', foo: f}

const globalPerson = person.foo;
globalPerson(); // Window {...}
```
위의 예제 처럼 메소드를 다른 변수에 할당한 뒤 호출하면, 메소드 호출이 아닌 일반 함수 호출이 되어 1번 규칙을 따라 `this`가 `window` 객체로 바인딩된다. 즉, **함수가 어디에 정의되었냐**가 아니라 **함수가 어떻게 호출되었냐**가 중요한 것이다.

#### 3. Constructor 내에서 - Constructor로 생성되는 객체
`constructor`는 객체를 생성해 주는 함수이다. `new` 키워드와 함께 쓰여 객체를 생성한다. 주로 구조가 같은 객체를 여러개 만드는 데 사용한다. 
```js
function Person (name, age){
    this.name = name;   
    this.age = age;
}
var me = new Person('Kim', 22);
var friend = new Person('Lee', 23);

console.log(me);        // {name: 'Kim', age: 22}
console.log(friend);    // {name: 'Lee', age: 23}
```
위 예제에서 `this`는 `new` 키워드로 생성된 빈 객체 자신을 뜻하는 일종의 플레이스홀더(정확히는 `new` 연산자가 만든 instance) 역할을 한다. 

#### 4. 이벤트리스너에서(Arrow function이 아닌 경우에만) - `e.currentTarget`
```html
<button id="btn">Button</button>
```
```js
document.getElementById('btn').addEventListener('click', function(e){
    console.log(e.currentTarget);   // <button id="btn">Button</button>
    console.log(this);              // <button id="btn">Button</button>
});
```
이벤트 리스너가 부착된 HTML 요소는 `e.currentTarget`으로 선택할 수 있다. 이때 이벤트리스너의 콜백함수 내에서 `this`는 `e.currentTarget`으로 바인딩된다. 
> 이벤트리스너의 콜백함수에서 파라미터로 받는 `e`는 이벤트 객체를 의미한다. 이벤트의 각종 정보가 들어있는 객체로, 이벤트가 일어난 HTML 요소, 마우스의 좌표 정보, 눌린 키보드 버튼 등의 정보를 알고 싶을 때 사용된다.
{: .prompt-info}

#### 5. Arrow function - 바깥 스코프의 `this` 바인딩
Arrow function은 자신만의 `this` 바인딩을 갖지 않기 때문에, `this` 값을 변화시키지 않는다. 대신 상위 스코프의 `this`값을 그대로 물려받아 사용한다. 
``` js
// Case 1
const obj = {
    arr: [1, 2, 3],
    func : function(){
        console.log(this);              // {arr: [1, 2, 3], func: f}
        this.arr.forEach(function(){
            console.log(this);          // Window {...} 3번 반복
        });
    }
}
obj.func();
```
``` js
// Case 2
const obj = {
    arr: [1, 2, 3],
    func : function(){
        console.log(this);              // {arr: [1, 2, 3], func: f}
        this.arr.forEach(() => {
            console.log(this);          // {arr: [1, 2, 3], func: f} 3번 반복
        });
    }
}
obj.func();
```
두 케이스 모두 `func` 메소드 내에서 `this`값은 `obj` 객체와 바인딩 된다. 1번 케이스의 경우 `func` 함수 내 forEach 반복문의 콜백함수로 `function(){}`을 이용하므로, 일반함수로서 독립적으로 호출하기 때문에 `this`가 `window`로 바인딩된다. 2번 케이스에서는 콜백함수로 Arrow function을 이용하여, `this`를 따로 바인딩 하지 않고 상위 스코프(`func`)를 그대로 사용하여 this는 obj가 된다.

#### 6. `call`, `apply`, `bind`에 의한 this 바인딩
`call`과 `apply`, `bind` 함수는 어떤 함수의 `this` 바인딩을 명시적으로 대체하려 할 때 사용하는 함수이다. A 객체의 메소드를 B 객체의 프로퍼티에 대해 사용하고 싶을 때 이용할 수 있다. 
``` js
var obj1 = {
    str: 'hello',
    print : function(){
        console.log(this.str);
    }
};
var obj2 = {
    str: 'hi'
};

obj1.print();        // 'hello'
obj1.print.call(obj2) // 'hi'
```
위 예제에서 `obj1.print();` 메소드는 `this`가 당연히 해당 메소드를 포함하는 객체인 `obj1`에 바인딩된다. 하지만 `obj1.print.call(obj2)`의 경우, `this`를 **`call`의 첫번째 인자로 들어간 `obj2`에 명시적으로 바인딩**해준다. 만약 함수에 파라미터가 들어가야 한다면 `call`의 첫번째 인자에 바인딩할 객체를, 두번째 인자부터 파라미터들을 순서대로 기입하면 된다. `apply`도 `call`과 같은 역할을 하지만, 2번째 인자에 함수에 들어갈 파라미터를 배열로 넣을 수 있다는 차이점이 있다. 만약 함수에 들어갈 파라미터의 갯수가 많거나 가변적이라면 `apply`를 이용해 배열로 간편하게 함수를 호출할 수 있을 것이다.

```js
function func1(){
    console.log(arguments.join());
}
func1(1, 2, 3); // Uncaught TypeError: arguments.join is not a function

function func2(){
    console.log(Array.prototype.join.call(arguments));
}
func2(1, 2, 3); // '1,2,3'
```

위 예제처럼 함수 내에서 `arguments` 객체와 같은 array-like (유사 배열) 객체에 `join`, `slice`와 같은 배열 전용 메소드를 사용하고 싶을 때 `call` 함수를 이용할 수도 있다.

> 일반적인 함수 호출에서는 파라미터로 배열을 사용할 수 없다. ES6 이전에는 `apply`의 부가적인 기능을 우회하여 사용하는 식으로 함수의 파라미터에 배열을 넣어 사용했다. `apply`는 위에서 말한 것처럼 파라미터로 배열을 넣을 수 있기 때문이다. `func.apply(undefined, arr)` 이런 식으로 첫번째 인자에 `undefined`나 `null` 값을 넣어 `this` 바인딩에 대한 기능은 무시하고, 그 뒤 인자로 배열을 넣어 함수를 호출하곤 했다. ES6부터는 `func(...arr);` 식으로 spread operator를 이용해서 배열을 전개하여 파라미터로 사용하는 것이 가능해졌다.
{: .prompt-info}



#### 정리 
위 규칙들 자체는 간단하지만, 케이스에 따라 어떠한 규칙을 적용해야 하는지 헷갈릴 수 있다. 이를 판단하기 위한 가장 중요한 규칙은 다음과 같다.
> `this` 바인딩은 함수가 어디에 정의되었는지는 중요하지 않다. **함수의 호출 방식**이 중요하다.

### 마무리하며
아직 나는 문법과 개념을 배우고 있다. 그래서 지금은 단순히 배운 키워드와 문법을 정리하는 형식으로 TIL을 작성하고 있다. 앞으로는 실제 프로젝트를 진행하며 마주친 난관들을 주제로 글을 쓰며, 실제로 배운 점과 느낀 점을 적어야 할 것 같다. 내가 개발자로서 성장하는 모습을 담을 수 있는 블로그가 되었으면 좋겠다.