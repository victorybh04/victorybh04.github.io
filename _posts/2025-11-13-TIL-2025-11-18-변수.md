---
title: TIL 2025/11/18 - var, let, const 
date: 2025-11-18 15:30:00 +0900
categories: [TIL, JS]
tags: [js]
---
## 들어가며
모든 프로그래밍 언어에서 기본이 되는 문법 중 하나가 바로 변수 문법이다. 나는 C++과 Python을 고등학생 때부터 가볍게 배웠었기에, JS를 공부하며 변수 문법이 발목을 잡진 않을거라 생각하고 있었다. 하지만 JS는 근본적인 작동 방식에 있어 다른 언어들과 차이가 있다. 기본적으로 타입을 지정할 수 없다는 점(동적 타입)부터, `var` 키워드의 경우 한번 선언한 변수를 재선언 할 수 있다는 점, 변수 호이스팅이 발생한다는 점 등에서 일반적인 언어와는 무언가 많이 다르다는 것을 느낄 수 있다. 오늘 변수 문법에 대해 공부하며 새롭게 알게 된 점과 어려운 개념들을 정리하고자 포스트를 작성한다.

## Today I Learned
### `var`와 `let`, `const` 키워드
변수 선언에 사용되는 세 키워드의 핵심 특징은 간단히 정리하면 다음 표와 같다. 
(`const` 키워드는 엄밀히 말하자면 변수가 아니라 상수이지만, 편의를 위해 `var`, `let`, `const` 모두 변수라 지칭하겠다.)

| Keyword | 재선언 | 재할당 | 스코프    |
| ------- | --- | --- | ------ |
| `var`     | O   | O   | 함수 스코프 |
| `let`     | X   | O   | 블록 스코프 |
| `const`   | X   | X   | 블록 스코프 |

이 특징들은 JS 기초 강의를 들으면서 배워 이미 알고 있는 내용들이다. 변수 문법의 특징이 이게 다였다면 이 포스트를 작성하지 않았겠지만... 세 키워드들은 다음과 같은 심화된 특징들을 가지고 있다.

#### 변수 호이스팅
``` js
console.log(a); // undefined
var a = 10;
console.log(a); // 10
```
변수 호이스팅(Hoisting)이란 변수 선언문이 해당 스코프의 가장 위로 끌어올려져 실행되는 것처럼 작동되는 현상을 말한다. 위 예제의 경우 다른 언어였다면 `a`라는 변수가 선언(정의)되지 않았다며 오류를 띄웠을 것이다. 하지만 JS에서는 `undefined`라는 값을 콘솔창에 띄운다. 이는 **var 키워드를 통한 변수 선언이 해당 스코프의 가장 위쪽에서 실행**되었고, `undefined` 값으로 초기화되기 때문이다. 변수 호이스팅 과정의 내부 동작을 간단히 풀어보면 다음과 같다.
``` js
var a;
console.log(a); // undefined (초기화)
a = 10;
console.log(a); // 10
```
즉, 선언 부분만 호이스팅되고, 할당은 기존 코드 위치에 그대로 남게 된다.

```js
console.log(b); // ReferenceError: b is not defined
let b = 10;
```
변수 호이스팅은 `var` 키워드에서만 유효하고, `let`과 `const`에서는 일어나지 않는다. `let`과 `const`를 위 예제처럼 사용하면 참조 오류가 나게 된다. 정확히는, 변수의 선언 자체는 세 키워드 모두 호이스팅된다. 하지만 `var`는 선언과 함께 `undefined`로 초기화까지 동시에 호이스팅되는 반면, `let`과 `const`는 선언만 호이스팅될 뿐 초기화 및 할당은 실제 코드 실행위치에서 이루어진다. 그래서 변수를 선언하고 변수가 할당되기까지 사이에 일시적 사각지대(Temporal Dead Zone, TDZ)가 생기게 되고, 이 구간에서 변수에 접근하려 하면 참조 오류가 발생하는 것이다.

> 변수 뿐만 아니라 함수를 선언할 때 역시도 호이스팅이 일어난다. 이때 함수는 함수의 내용까지 모두 함께 호이스팅되어, 변수 호이스팅과는 다르게 실질적으로 사용이 가능해진다. 즉, 함수 선언부를 코드의 최하단에 몰아놓고, 상단에서 함수를 호출하여 사용하는 것이 가능하다.
{: .prompt-info}

#### 전역 객체 `window`의 프로퍼티 여부
저번 `this` 바인딩 포스트에서 `window` 전역 객체에 대해 간단히 설명한 적이 있다. (`node.js`가 아닌 브라우저 환경에서의) 모든 전역 변수, 함수, DOM을 저장하고 관리하는 전역 객체를 `window`라고 한다.
```js
var a = 10;
console.log(window.a);  // 10
console.log(a);         // 10
```
위 예제처럼 `var` 키워드로 선언된 변수는 이 전역 객체의 프로퍼티가 된다.

``` js
var a = 1;
let b = 2;
window.a = 3;
window.b = 4;

console.log(a);         // 3
console.log(b);         // 2
console.log(window.a);  // 3
console.log(window.b);  // 4
```
하지만 `let`과 `const`로 선언된 변수는 전역 객체에 저장되지 않는다. 즉, 위 예제에서 `let b = 2;`와 `window.b = 4;`는 각각 서로 다른 변수를 지칭하게 되는 것이다. 

> **그러면 let과 const로 선언한 변수들은 어디에 저장되는가?** `window` 객체와는 별개의 독립적인 공간에 저장된다. 이 공간을 렉시컬 환경(Lexical Environment)라고 한다. `var` 키워드를 이용할 때 `window` 객체 내의 중요한 프로퍼티와 이름이 겹쳐 (네임스페이스) 심각한 버그를 일으킬 수 있기 때문에 `let`과 `const` 키워드가 도입되었다고 한다. (물론 도입된 이유에는 그 외에도 다양한 이유들이 있다.) 
>
> 렉시컬 환경은 현재 실행중인 코드 블록의 식별자를 관리한다고 한다. (자세한 내용은 '실행 컨텍스트'라는 개념과 '렉시컬 스코프'라는 개념에 포함된다고 하는데, 이러한 개념들은 아래 블록 스코프의 예시에서 간단히 맛보게 될 것이다.)
{: .prompt-info}

#### 함수 스코프와 블록 스코프
`var`는 함수 스코프를 가지지만, `let`과 `const`는 블록 스코프를 가진다. 중괄호 `{}`로 싸여진 코드 블록이 변수의 생존 범위라는 것이다. 따라서 `var`와 `let`은 `for`문과 `if`문 같이 코드 블록을 사용하는 문법에서 다르게 동작한다.
```js
for (var i = 0; i < 5; i++) { 
    setTimeout(function() { console.log(i); }, i*1000 ); 
}
```
위 예제는 1초 간격으로 콘솔에 0부터 4까지를 출력하는 코드이다. 하지만 실제로 작동 시 5 만 다섯 번 출력된다. 

제대로 동작하지 않는 이유는 다음과 같다. `var`의 경우 함수 스코프를 가지고, `for`문은 함수가 아니므로 `var i`는 전역변수이다. `for` 루프가 순식간에 끝나며 전역변수 `i`는 5가 된다. 0 ~ 4초 뒤 5개의 콜백 함수가 순차적으로 실행될 때, `console.log(i)`는 전역변수 `i`를 참조하게 된다. 이 `i`는 이미 5이므로, 5만 다섯 번 출력되는 것이다.

따라서 `var` 키워드를 `let`으로 바꾸면 변수 `i`가 블록 스코프를 가지게 되어 정상적으로 동작하게 된다. 

> `i`가 전역변수로 남게 되어 5가 다섯 번 출력되는건 이해가 된다. 그런데 `let`을 사용한다고 해도 블록 스코프 안에서 `i`가 1000ms마다 값이 바뀌게 되는데 어떻게 콜백함수 내에서 i를 제대로 출력할 수 있을까? 
>
> 처음에 나는 이를 콜 스택(Call Stack)에 의해 설명할 수 있을 거라 추측했다.~~(얕은 지식으로 주워들은 개념이다.)~~ 
>
> 실제로 `for`문 내의 코드들이 순식간에 진행되며, 콜 스택에 순서대로 `setTimeOut` 함수가 올라오게 된다. `setTimeOut`은 일정 시간 후에 콜백함수를 실행해달라는 **비동기 요청**으로, 콜백함수를 **Web API**에 던져주고 스택에서 바로 사라지게 된다. 즉 `for`문은 1초는 커녕 0.01초도 안걸려서 순식간에 실행되고 콜 스택의 (동기적)작업은 여기서 끝난다. **console.log(i)는 `for`문이 도는 동안 콜 스택에 한번도 올라온 적이 없다.** 콜 스택은 내 의문에 핵심 답변이 될 수 없다.
> 
> 비동기 처리는 **Web API**라는 별도의 창구에서 진행되게 된다. 여기서 5개의 타이머가 돌아가고, 타이머가 끝날 때마다 **콜백 큐(CallBack Queue)**라는 대기열에 콜백함수 `function(){ console.log(i) }`가 올라간다. 콜백 큐에서 타이머가 된 콜백함수들을 **이벤트 루프**가 다시 콜 스택으로 올려 실제로 `console.log(i)`가 실행된다.
>
> 사실 핵심은 여기부터이다. `for (let i ...)`는 특별하게 동작한다. `for` 루프를 한번 돌 때마다 `{}` 블록 스코프가 새로 생기게 된다. 그 스코프 안에 `for` 기준 `i`의 값을 복사한 별개의 `i` 변수가 생성된다. `setTimeOut에` 전달된 콜백 함수는 이 별개의 `i`를 **클로저(Closure)**라는 것으로 붙잡아 두게 된다. (클로저는 자신의 선언될 때의 스코프를 기억하는 함수 라고 한다.) **결론은 `for` 루프마다 생성된 블록 스코프에서 클로저의 `i`값을 참조하기 때문에 `for`문이 진작에 끝났어도 제대로 `i`를 출력할 수 있는 것이다.**
> 
> 이 일련의 과정을 정확히 이해하려면 실행 컨텍스트, 렉시컬 환경, 렉시컬 스코프, 콜 스택, Web API, 콜백 큐, 이벤트 루프, 클로저와 같은 개념들이 필요하다. AI의 도움을 받아 대강의 프로세스만 이해하며 글을 작성했기에 오류가 있을 수 있다. 앞으로 이러한 심화 개념을 확실히 이해할 필요가 있어 보인다.
{: .prompt-info} 

## 마무리하며
본문의 예제들을 살펴보며 느낀 점은, `var` 키워드가 상당히 문제점이 많다는 것이다. `var` 키워드를 사용했을 때 생기던 문제들이 `let`으로 바꾸기만 하면 해결되는 예제가 2개나 있다. 이번 학습을 통해 ES6가 되며 추가된 `let`과 `const` 키워드를 적극적으로 사용하는 것이 모던 웹개발에서 권장되는 이유를 알 수 있었다. (`var`의 함수 스코프 때문에 전역변수가 남발되는 문제가 큰 듯하다.)

서론에서 이야기했듯 역시 JS는 다른 언어들과는 차별점이 큰 듯하다. JS를 공부하며 '왜 이런식으로 언어를 특이하게 설계했을까?' 라는 생각을 하곤 하는데, 모든 것엔 이유가 있는 법이다. 처음으로 `var`키워드의 스코프 문제에 대해 공부했을 당시 역시 '왜 처음부터 `let`처럼 구현하지 않았을까?'라는 의문이 들었다. 그런데 아래의 예제의 경우 `var`의 특성이 유리하게 작용한다.

```html
<script src="script1.js"></script>
<script src="script2.js"></script>
```
HTML 파일에는 스크립트 파일을 여러 개 추가하곤 한다(e.g. 크롬 확장프로그램). 위 예제에서 `var` 키워드와 함수가 `window` 전역 객체의 프로퍼티가 되는 특징이 없었다면, `script2.js`에 선언된 함수와 변수를  `script1.js`에서 사용하기 매우 까다로웠을 것이다 - 함수를 일일히 다시 선언하여 작성하거나, import를 통해 해당 기능을 가져와야 할 것이다. 하지만 `var`와 함수 선언문이 `window` 전역 객체 아래에 프로퍼티가 되어, 전역 스코프를 공유하기 때문에 이러한 작업 없이 유연하게 코드 작성이 가능해진다. (`var`의 작동 방식이 스크립트 간의 느슨한 연결을 가능하게 했던 것이다.) 