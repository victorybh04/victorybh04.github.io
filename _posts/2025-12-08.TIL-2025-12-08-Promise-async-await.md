---
title: TIL 2025/12/08 - Promise, async, await 
date: 2025-12-08 15:30:00 +0900
categories: [TIL, JS]
tags: [js]
---

## 들어가며
JS는 여러모로 다른 언어들과 많은 차별점을 가지고 있는 언어지만, 그 중에서도 가장 두드러지는 특징을 하나 꼽으라면 비동기 처리를 들 수 있겠다. 사실 JS 자체는 기본적으로 동기적으로 코드를 실행하지만, JS의 핵심 문법 몇가지는 비동기적으로 작동하여 우리를 혼란스럽게 만들곤 한다. 대표적으로 `setTimeout`, `fetch` 등이 있겠다. 

비동기 방식을 이용하면 '어떠한 요청의 처리'와 '그 결과를 이용하는 새로운 요청'이 순서대로 이루어진다는 보장을 할 수 없다. 그래서 비동기 작업 이후에 일어나야 하는 작업을 콜백 함수에 집어넣어 순서를 끼워 맞추는 식으로 코드를 짜게 된다. 

하지만 복잡하게 얽힌 비동기 처리의 경우, 콜백 함수를 몇 번씩이나 사용하면 코드가 옆으로 길어진다는 문제가 발생한다. 이를 콜백 지옥(Callback Hell)이라고 하는데, 가독성이 떨어지는 것은 물론이고, 수정도 어려워지게 된다. 따라서 이러한 패턴은 지양해야 할 것이다.

![Callback Hell](https://velog.velcdn.com/images/okvv26/post/4f6dbbf7-ef57-4733-b7e4-8e85e2f7a63c/image.png){: w="500"}
_콜백 지옥_

이러한 안티 패턴을 해결할 방법이 오늘 포스팅할 `Promise`와 `async`, `await` 키워드이다.

## Today I Learned
### Promise
`Promise`(프로미스)는 콜백 지옥을 해결해주기 위한 새로운 객체이다. `Promise` 객체는 기본적으로 '성공'과 '실패' 상황을 판정할 수 있도록 해주는 객체이며, 이에 따라 `then`과 `catch`로 프로그램의 동작 순서를 가이드해줄 수 있다. 

#### Promise의 3가지 상태
프로미스에는 다음과 같은 세가지 상태가 있다. 

1. Pending (대기) - 비동기 처리가 완료되지 않은 상태
2. Fulfilled (성공) - 처리가 성공적으로 완료되어 결과 값을 반환한 상태
3. Rejected (실패) - 처리가 실패하거나 오류가 발생한 상태

#### Promise 사용법
보통 비동기 함수들이 `Promise` 객체의 콜백 함수에 들어간다. 이 콜백 함수는 1번째 파라미터로 `resolve`, 2번째 파라미터로 `reject`를 받는다(파라미터의 이름은 바꿔도 된다). 그 안에서 비동기 작업을 수행한 후 `resolve` 또는 `reject`를 호출하여 성공과 실패를 판정하고, `then` 또는 `catch` 메소드로 다음 작업을 진행하는 식으로 사용한다. 

``` js
let testPromise = new Promise(function(resolve, reject){
    let result;
    setTimeout(function(){  // ex. DB에서 데이터를 꺼내오는 과정이 3초 걸린다고 가정
        result = 1000;
        resolve(result);    // resolve로 결과값을 전달
    }, 3000);
});

testPromise
    .then( (value) => {
        console.log(value); // 3초 후에 1000 출력
    })
    .catch( (error) => {
        console.log(error);
    });
```
위 예제에서, 3초 전까지는 `testPromise` 객체를 출력해보면 `Promise {<pending>}`으로 아직 대기 중임을 확인할 수 있다. 3초 후에는 `then` 구문이 실행되는데, 
1. `resolve(result)`의 `result`가 
2. `then`의 콜백 함수의 `value` 파라미터로 들어가 
3. `1000`을 출력하게 된다. 

그리고 `testPromise` 객체를 출력해보면 `Promise {<fulfilled>: 1000}`로 바뀌어 있다. 실제 코드를 작성할 때라면, DB에서 데이터를 비동기적으로(3초간) 받아온 후 값을 받아 활용하는 식으로 사용할 수 있는 것이다. 

#### Promise Chaining
```js
// testPromise 정의 생략

testPromise
    .then( (value) => {
        console.log(value); // 1000
        return value * 2;   // 다음 .then으로 2000 넘김
    })
    .then( (value) => {
        console.log(value); // 2000
        return value * 3;   // 다음 .then으로 6000 넘김
    })
    .then( (value) => {
        console.log(value); // 6000
    })
```
프로미스의 가장 강력한 장점은 Chaining을 통해 흐름을 직관적으로 표현할 수 있다는 것이다. 위 예제처럼 각 `then`에서 리턴한 값은 다음 `then`의 입력값(파라미터)로 쓰이게 된다. 콜백 함수 안에 콜백 함수를 계속 넣는 콜백 지옥 대신, `then`을 이용하면 코드가 오른쪽으로 길어지지 않고 코드의 실행순서 또한 명백히 보여 가독성이 좋아지게 된다. 

#### Promise를 반환하는 함수들
```js
let ajaxPromise = fetch(url)
    .then( (res) => res.text() );

ajaxPromise
    .then( (data) => {
        console.log(data);
    })
    .catch( (error) => {
        console.log('failed', error);
    });
```
`fetch`, `axios`와 같은 라이브러리는 Ajax 요청을 할 때 `then` - `catch` 문법을 이용하는 경우가 많다. `fetch()` 또는 `axios.get()` 메서드를 통해 반환되는 결과값이 프로미스 객체이기 때문에, `then` 메서드를 통해 비동기 처리의 결과를 사용할 수 있는 것이다. 해당 함수의 내부적으로는 `Promise` 객체에서 `resolve`로 Ajax 요청의 결과를 전달한다고 생각해볼 수 있다.

```js
console.log( fetch(testUrl) );  // Promise {<pending>}
```
실제로 `fetch`를 `console.log`로 찍어보면 그 결과로 프로미스 객체를 반환하는 것을 확인할 수 있다.

> 위 예제의 `fetch(url).then( res => res.text() )`부분에서 이미 `then`으로 `res.text()`를 반환하는데, 다시 한번 `ajaxPromise.then`으로 콘솔에 띄우고 있다. `fetch`를 사용하는 경우 왜 두 번이나 `then`을 사용해야 할까? 
>
> `fetch` 메서드의 경우 응답 헤더(200, 404와 같은 응답코드, 그 외에 여러 메타데이터)가 먼저 도착할 때 첫 번째 프로미스가 resolve된다. 하지만 본문은 아직 다 받지 못한 상태이다. 실제 데이터는 응답 헤더 이후 데이터 스트림(Stream) 형태로 쪼개져서 전송되기 때문이다. 따라서 `res.json()`이나 `res.text()`로 본문을 끝까지 읽어들이는 작업을 하고, 아래에서 두 번째 프로미스를 기다리며 `ajaxPromise.then()`으로 실제 데이터인 `data`를 출력할 수 있는 것이다. 
>
> `Axios` 라이브러리를 사용하면, `axios.get`으로 ajax 요청할 때 두번째 단계를 내부적으로 처리해주어 json 자료형으로 변환까지 해준다. 즉 한번의 `then` 사용으로 json 데이터를 이용할 수 있다. 
{: .prompt-info }

### async, await
`Promise` 문법은 콜백 지옥을 해결해주기에 편리하지만, 사실 문법 자체가 보기 좋지는 않다. `Promise`를 사용하고 싶을 때마다 `new Promise`로 프로미스 객체를 생성하고, 그 안의 콜백함수에 실제 기능을 작성해야 하므로 사용이 어렵고 직관적이지 않다. 이를 해결해 주는 것이 `async` 와 `await` 키워드이다. 

```js
async function sum(){
  return 1 + 1; 
}

sum().then( (res) => {
  console.log(res)  // 2
});
```
**`async` 키워드는 function 선언 앞에 붙여 해당 함수가 프로미스 오브젝트를 반환하도록 만든다.** 즉 `new Promise ~~~`로 프로미스를 선언할 필요 없이, 함수를 만들고 `async` 키워드를 붙여주는 것 만으로 프로미스 객체를 만들 수 있는 것이다. 따라서 위 예제처럼 함수 뒤에 `then`을 붙여 순서를 지정해 사용할 수 있다. 

```js
async function ajax1(url) {
    const res = await fetch(url);
    const data = await res.text();
    return data;
}
ajax1(testUrl).then((res) => {
    console.log(res);
})

fetch(testUrl)
    .then((res) => {
        return res.text()
    })
    .then((data) => {
        console.log(data);
    })
```
**`await` 키워드는 `then`을 대체할 수 있는 문법이다.** 위 예제에서 두 코드는 같은 역할을 한다. `await`은 `async`로 선언한 함수 안에서만 사용되는 연산자이다. `async` 함수 내에서 `await` 키워드를 만나면, 해당 작업이 끝날 때까지 실행 컨텍스트를 일시중지시킨다. (이 정지는 함수 내부에서만 일어나며, JS 전체가 멈추는 것은 아니다.)

다시말해 `await` 키워드를 이용하면 비동기 코드가 완료될 때까지 기다렸다가 해당 비동기 코드가 완료되면 다음 코드로 넘어간다. 즉 `await`은 비동기 흐름을 유지하면서도, 코드 구조를 동기처럼 보이게 해준다. 이렇게 일반 코드를 짜듯 순서대로 코드를 짜고 앞에 `await`만 붙이면 되므로 코드를 작성하기도 편하고, 가독성이 좋아지게 된다.

#### `try` - `catch` 
`async` - `await` 구조에서는 `await` 뒤 프로미스가 실패하면 그 뒤 코드가 실행되지 않는다. 대신 `try` - `catch` 구문을 이용해 프로미스가 실패할 경우의 에러 처리를 할 수 있다.

### 주의점
`Promise`는 ES6 (ECMAScript 2015)에서 추가된 문법이다. 그리고 이를 더 간편하게 사용할 수 있게 해주는 `async`와 `await` 문법은 ECMAScript 2017에서 추가되었다. 최신 브라우저들은 잘 지원하겠지만, IE와 같은 구형 브라우저에서는 지원되지 않을 수 있으므로 호환성이 중요하다면 해당 문법들을 사용하지 않아야 한다.

그리고 `Promise`는 동기 코드를 비동기 코드로 만들어주는 문법이 아니다. 그저 복잡한 비동기 처리를 할 때 콜백 지옥을 해결하기 위한 디자인 패턴일 뿐이다. 예를 들어 10초 걸리는 수학 연산을 `Promise` 안에 넣어놓는다고 해서 해당 코드를 Web API에 제껴두는 방식으로 작동하지 않으며, 결국 10초 동안 브라우저가 멈추게 된다. 즉 `Promise`는 기다리는 동안 이벤트 루프에서 제어권을 넘겨줄 뿐, CPU 연산을 자동으로 다른 스레드에서 처리해주지 않는다(멀티 스레딩을 위한 문법이 아니다).

## 마무리하며
Findit 프로젝트에서 백엔드 서버로 `node.js`의 `express`를 선택하였다. 백엔드 서버 `server.js`를 구현할 때, 다음과 같이 `async`와 `await` 문법을 사용하였다. 당시 코드를 작성할 때에는 `async`와 `await`이 어떠한 역할을 하는지도 몰랐으나, 그냥 문법만 외워 사용하며 넘어가곤 했다.

```js
app.get('/search', async (req, res) => {
    // ...
    try {
        const naverApiUrl = `https://openapi.naver.com/v1/search/shop.json`;
        const naverResponse = await axios.get(naverApiUrl, 
        { 
            // ...
        });
        // ...
    } catch(error) {
        // ...
    }
});
```

이번에 `Promise`와 `async`, `await`을 공부하면서 이젠 이 코드가 어떤 구조로 작동하는지 알게 되었다. 
클라이언트에서 `/search` API 엔드포인트로 get 요청을 받으면, `app.get`의 콜백함수인 화살표 함수에 `async`를 붙여 비동기 처리가 필요함을 선언한다. 그리고 `await axios.get(naverApiUrl, ~)` 코드에 도달하면 네이버쇼핑 API로 요청을 보내고 데이터를 받을 때까지 기다리며, 데이터를 받고 나면 그 이후 코드를 실행하게 된다. 

백엔드 서버는 매번 외부 API에 Ajax 요청하거나, DB에 대한 IO작업을 수행하곤 한다. ajax 통신이나 IO작업이나 모두 비동기적 프로세스이다. 따라서 `node.js`로 백엔드를 개발하다 보면 프로미스 역시 거의 무조건 사용하게 된다. 결국 `node.js`에서 비동기 흐름을 제대로 제어하려면 `Promise`를 확실히 이해하는 것이 필수이다.