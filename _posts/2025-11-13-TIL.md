---
title: TIL 2025/11/13 - this 바인딩
date: 2025-11-13 15:00:00 +0900
categories: [TIL, JS]
tags: [js]
---

## TIL을 시작하며
나는 현재 `HTML`, `CSS`, `JS`의 기초를 온라인 강의를 통해 공부했다. 지금까지는 단순히 강의를 들으며 만든 결과물(숙제, 포트폴리오 실습)들을 비공개로 Github에 백업하기만 했다. 문제는 남는 것이 없다는 것이다. 최대한 정답지를 보지 않고 몇시간 씩 고민해가며 결과물을 완성하긴 했지만, 저 결과물들을 Github에 올려두는 것 만으로는 아무도 알아주지 않는다. 사실 해설 강의를 보고 따라치기만 해도 만들 수 있는 것들이기 때문이다. 그래서 이제부턴 내가 배운 것들을 정리하고 기록하고자 TIL 포스팅을 시작하기로 했다.

이 포스팅을 시작한 또 다른 한가지 이유는 나는 더 이상 기초 문법 수준에 머무를 수 없다는 것이다. 지금 나는 Findit 프로젝트를 진행하고 있는데, 생각보다 기초 문법을 아는 것만으론 할수 없는게 많다는 것을 깨달았다. 생각해보면 당연한 이야기이다. 실제 프로젝트의 코드들을 살펴보면 아직 배우지 못한 `this`, `new`, `async`와 `await` 같은 키워드 들이 즐비할 뿐더러, 편리한 개발을 위해 만들어진 다양한 라이브러리와 프레임워크를 사용할 때마저 이러한 키워드들이 필수적으로 사용된다. 그리고 나는 `prototype`, `getter`, `setter`와 같은 객체지향과 관련한 개념은 아예 감도 잡지 못했다. 그러기에 본격적으로 `React`와 `Next.js`를 공부하기 전에 JS 심화 강의를 듣기로 했고, 중고등학교 시절 개념을 노트에 정리해가며 공부했듯 이젠 TIL 포스팅을 통해 배운 것들을 정리해가며 공부하고자 한다.


## Today I Learned
### `this` 키워드
나에게 `this` 키워드는 일종의 만능 키워드라고 생각한다. 내가 지금까지 배운 수준에서 `this`는 이벤트리스너에서 이벤트가 일어난 HTML 요소를 선택하고 싶을 때 사용하는 `event.currentTarget`을 `this`로 치환하여 사용하기도 하고, 객체 내의 형제 요소들을 선택하고자 할 때 `this` 키워드를 사용하기도 하였다. 만능이라는 것은 기능이 많다는 뜻이지만, 그만큼 그 실체를 어떠한 것으로 딱 집어 정의하기 어렵다는 뜻이기도 하다. 

자바스크립트의 심화 문법들과 객체지향을 설명하는 강의를 결제한 김에, 내 머릿속에 뒤죽박죽이던 개념들 중 하나였던 `this`를 정리해보기로 한다. 

#### 1. 일반 함수일 경우 - 해당 함수가 포함된 상위 객체
##### 1-1. 전역 스코프에서 호출
```js
console.log(this)       // (1) - Window {...}

function foo(){ console.log(this); }
foo();                  // (2) - Window {...}
```
전역 스코프에서 호출된 함수의 경우 this는 `Window {...}` 객체를 의미한다. 이는 해당 함수가 포함되어 있는 상위 객체가 `window` 객체이기 때문이다. 위 예제에서 (1)과 (2) 모두 전역 스코프 아래에 존재하므로, 두 경우에서 `this`는 모두 `window` 객체에 바인딩된다. 

다만, `'use strict'` 엄격 모드를 사용하는 경우에 `this`는 `undefined`가 된다. 이는 `window` 객체를 `this`로 오염시키는 것을 막기 위함이라고 한다.

> **`window` 객체란?**
> > 모든 전역 변수, 함수, DOM을 저장하고 관리하는 전역 객체.
>
> 라고 하는데, 쉽게 말하자면 
> 1. `document.getElementById()`, `console.log()`와 같은 함수들을 포함하고, 
> 2. 내가 선언한 전역변수들을 보관하며,
> 3. HTML 요소들을 저장하는 DOM을 보관하는 
> 
> 모든 것을 담아내는 큰 객체라는 뜻이다.
>
>즉 위 예제에서 `foo()`라는 함수는 사실 `window.foo()`로도 동일하게 호출할 수 있다. 
>(다만 브라우저 환경에서만 `window` 객체가 존재하고, `node.js` 환경에서는 `global` 객체가 대신한다고 한다.)
{: .prompt-info}

##### 1-2. 객체 내 메소드 호출
```js
const person = {
    name: 'Kim',
    hi: function(){
        console.log(this);
        console.log('Hi,', this.name);
    }
};
person.hi();    // person {name: 'Kim', hi: f}
                // 'Hi, Kim'
```
여기서 `hi`는 `person`이라는 객체에 포함된 메소드이다. 그래서 `this`는 `person` 객체를 의미하게 된다.
```js
const obj1 = {
    obj2: {
        foo: function(){ 
            console.log(this);
        }
    }
};
obj1.obj2.foo()    // {foo: f} (== obj2)
```
중첩되어 있는 객체의 경우에도, this는 해당 메소드가 포함된 바로 상위의 객체를 의미하게 된다. 따라서 위 예제에서 `foo` 메소드에서의 `this`는 `obj2`에 바인딩된다. 


### 2. Constructor 내에서 - Constructor로 생성되는 객체
`constructor`는 객체를 생성해 주는 함수이다. `new` 키워드와 함께 쓰여 객체를 생성한다. 주로 구조가 같은 객체를 여러개 만드는 데 사용한다. 
```js
const Person(name, age){
    this.name = name;   
    this.age = age;
}
var me = new Person('Kim', 22);
var friend = new Person('Lee', 23);

console.log(me);        // {name: 'Kim', age: 22}
console.log(friend);    // {name: 'Lee', age: 23}
```
위 예제에서 `this`는 `constructor`로 생성될 빈 객체 자신을 뜻하게 된다. 

### 3. 이벤트리스너에서 - e.currentTarget
```html
<button id="btn">Button</button>
```
```js
document.getElementById('btn').addEventListener('click', function(e){
    console.log(e.currentTarget);   // <button id="btn">Button</button>
    console.log(this);              // <button id="btn">Button</button>
});
```
이벤트리스너에서 이벤트가 일어난 HTML 요소는 e.currentTarget으로 선택할 수 있다. 
> 이벤트리스너의 콜백함수에서 파라미터로 받는 e는 이벤트 객체를 의미한다. 이벤트의 각종 정보가 들어있는 객체로, 이벤트가 일어난 HTML 요소, 마우스의 좌표 정보, 눌린 키보드 버튼 등의 정보를 알고 싶을 때 사용된다.
{: .prompt-info}

#### 정리 
이 모든 Case들을 하나의 규칙으로 깔끔하게 정리하자면 다음과 같다.
> this 바인딩은 함수가 어디에 정의되었는지는 중요하지 않다, **함수의 호출 방식**이 중요하다.
1. 전역 스코프에서 일반 함수 호출일 때
```js
this === Window {...} (전역 객체)
```
- 

2. 메서드 호출일 때
this 

## 어따써먹지