---
title: Findit - 프로젝트를 시작하며
date: 2025-11-10 17:45:00 +0900
categories: [Project, Browser-Extensions]
tags: [findit]
---
<a href="https://github.com/victorybh04/findit/tree/main" target="_blank">Findit Github 링크</a>


<!-- # 서론 -->
Findit 프로젝트는 온라인 쇼핑몰의 상품들을 찾아주는 브라우저 익스텐션(Browser Extensions) 프로젝트다. 특정 상품 페이지에 접속했을 때, 다른 쇼핑몰에서 **완전히 일치하는 상품을 검색**하여 **최저가 판매처를 찾아주는 것**이 이 익스텐션의 기본적인 기능이자 목표이다. 이 포스트에서는 어떻게 이 프로젝트를 시작하게 되었는지, 앞으로 어떻게 개발해 나갈 것인지에 대해 가볍게 설명하고자 한다.

<!-- # 본론 -->
## 왜 브라우저 익스텐션인가
현재 나는 대학교 2학년 초보 개발자이다. 전공은 컴퓨터와 관련이 없으나, 프로그래밍에 대한 개인적인 취향과 열정으로 개발 공부를 시작하게 되었다. 내 작업물의 결과가 시각적으로 잘 보이는 프론트엔드 웹 개발이 개발자 커리어로 시작하기에 최적이라 생각하여, 일단 `HTML`, `CSS`, `JS` 기초를 배웠다.

이 기술 스택으로 단순히 웹 페이지를 만드는 것도 좋지만, 나는 보다 기능적인 무언가를 만들어 보고 싶었다. 그러던 와중 한 유튜버가 ~~(어둠의 생활코딩)~~ 올린 '브라우저 익스텐션 개발로 떼돈을 버는 사람들'이라는 영상이 내 이목을 끌었다. 일단 재밌어 보이기도 하고, 현재까지 배운 것들로 시도해보기 좋은 프로젝트라 브라우저 익스텐션 제작 프로젝트를 시작해 보기로 했다.

## 왜 가격 비교 프로그램인가
> 모든 위대한 발명은 사소한 불편함에서부터 시작된다.

누군가가 한 격언은 아니고, 일반적으로 받아들여지고 있는 말이다. 이 프로젝트 역시 ~~(위대한 발명이 될 지는 모르겠다만)~~ 단순히 온라인으로 쇼핑을 할 때 최저가를 찾기 위해 여러 쇼핑몰들을 방문하는 불편했던 경험으로부터 시작한다. 나 뿐만 아니라 많은 사람들이 겪고 있을 불편함이라 생각하여, 가격 비교 프로그램을 접근성 좋은 브라우저 익스텐션으로 만들면 좋을 것 같다고 생각하였다.

***
## 현재까지 개발 경과
전역 후 2025년 10월부터 현재(11월)까지 약 1달간 프로젝트를 진행했다. 언제까지 프로젝트를 완성하겠단 계획은 아직 없다. 사이드 프로젝트는 기간을 정해놓고 스프린트 식으로 진행하는게 좋다는 말을 들은 적이 있는데, 그건 바쁜 직장인들의 이야기이고 난 아직 휴학 중이니, 복학까지 남은 시간동안 하고싶은 일들을 하면서 동시에 천천히 개발의 템포를 끌어올릴 것이다.

### popup.html
![popup.html](/assets/img/findit/1-popup.png){: w="500"}
_아직 목업 데이터만 들어가는 수준이다._

팝업은 브라우저에서 확장 프로그램 아이콘을 클릭했을 때 나타나는 페이지이다. 즉 브라우저 익스텐션의 얼굴과도 같다. 위 사진처럼 일단 큰 디자인적 요소가 없는 UI로 완성했다. 

### manifest.json (Manifest V3)
`manifest.json`은 브라우저 익스텐션의 메타데이터를 저장하는 파일이다. 브라우저 익스텐션의 이름과 설명, 권한 등을 설정하는 역할을 한다. 즉, 브라우저 익스텐션을 개발 할 때에 필수적으로 작성해야 하는 파일이다. 개발 과정에서 익스텐션의 기능을 확장하면서 `manifest.json`의 내용을 수정해야 한다.

`Manifest V3`는 구글에서 규정하는 브라우저 익스텐션 플랫폼에 적용하는 일종의 규칙들이다. V3 버전이 되며 보안 강화와 더 많은 API를 지원하게 되었다고 한다. 

### popup.js
아래의 `content.js` 파일을 현재 쇼핑몰 페이지 HTML에 삽입한다.
서버에 상품명을 전달하고, `response`로 받은 json 파일을 이용하여 `popup.html`에 카드와 링크 생성하는 기능까지 만들었다.

```js
// content.js에 GET_PRODUCT_TITLE 메시지를 발송
chrome.tabs.sendMessage(
    currentTab.id, // 현재 탭 정보
    { type: 'GET_PRODUCT_TITLE' },
    (response) => { ...
        updateTitle(response.title);
        const encodedTitle = encodeURIComponent(response.title);
        fetch(serverIP + '/search?q=' + encodedTitle) // 백엔드 서버에 GET 요청
            .then(response => response.json())
            .then(data => {
                const results = data.results;
                if (results.length > 0) {
                    document.querySelector('.result-list').replaceChildren();
                    renderResults(results);
                } else {
                    document.getElementById('loading-message').innerText = '검색 결과가 없습니다.';
                }
            })
            .catch(error => {
                document.getElementById('loading-message').innerText = '서버와의 연결에 실패했습니다.';
                console.warn('서버와의 연결에 실패했습니다.', error);
            });
    }
);
```
`content.js`에 Chrome Extension API를 통해 메시지를 보내고 응답을 받아 백엔드 서버로 요청을 보내는 `popup.js`의 핵심 코드이다.

### content.js
열려있는 쇼핑몰 페이지의 HTML을 읽어서 상품명을 가져오고, `popup.js`로 다시 상품명을 전달하는 코드이다. 

```js
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.type === "GET_PRODUCT_TITLE") { // 1. popup.js로부터 상품명체크 요청 확인
        const title = getProductTitle(); // 2. 현재 페이지 상품명 받기
        console.log('title');
        sendResponse({ title: title }); // 3. popup.js로 응답 전송
    }
    return true; // 비동기 응답을 위한 true 반환
});
```
Chrome Extension API로 메시지를 받을 때 실행되는 코드이다.

```js
function getProductTitle() { // 현재 페이지에서 상품명 (title)을 반환하는 함수
    const hostname = window.location.hostname; // 현재 페이지 주소
    let title = '';
    try {
        if (hostname.includes('coupang.com')) {
            title = document.querySelector('.product-title').innerText;
        } else if (hostname.includes('aliexpress.com')) {
            title = document.querySelector('.title--wrap--UUHae_g').innerText;
        } else {
            title = '쇼핑몰 페이지가 아닙니다.'
        }
    } catch (e) {
        console.warn('Findit : 상품명을 찾을 수 없습니다.', e);
        title = '상품명 찾기 실패';
    }
    return title.trim();
}
```
쿠팡과 알리익스프레스에서 상품명을 가져오는 함수의 코드이다. 

### server.js
 `node.js`의 `express` 프레임워크를 통해 JS로 백엔드 서버를 작성했다. 백엔드 프레임워크는 Python 기반의 `Django`, `Flask`나 JAVA 기반의 `Spring boot`이 유명하지만, `express`를 선택한 이유는 다음과 같다.
1. 문법이 **간결**하고 **익숙**하다.
당연하지만 프론트엔드를 배우며 JS를 공부했기 때문에, JS의 기본 문법이 익숙하여 백엔드 서버 개발 시에도 편리하다. 또한 `express`는 문법이 간결하기로 유명하다.

2. 백엔드 프레임워크가 제공하는 다양한 **고급 기능들이 필요 없다**.
`Spring boot`나 `Django`와 같은 백엔드 프레임워크들은 DB 입출력(데이터 관리), 로그인 기능(사용자 인증), 보안 기능 등의 다양한 기능들을 기본으로 제공하곤 한다. 하지만 이는 일반적인 웹페이지에서나 필요한 기능들이고, 이 프로젝트에서는 외부 쇼핑몰로의 요청과 응답 수신(I/O 작업), 검색어 처리 등의 기능만 하기에 이러한 내장 기능들은 필요없다. 또한 이런 I/O와 텍스트 처리는 그렇게 강력한 컴퓨팅 파워를 요구하지도 않기에, 싱글 스레드로 동작하는 `node.js`로도 충분히 운용이 가능하다 판단했다.

![popup.html](/assets/img/findit/1-async.png){: w="500"}
_동기 처리와 비동기 처리에 따른 처리 시간 차이_

3. **비동기 처리**와 **non-blocking I/O** 특성

대부분의 웹 서버에서는 내부 DB 접근이나 사용자 요청 처리 정도가 주요 I/O 작업이다. 하지만 이 프로젝트에서 백엔드 서버는 수많은 쇼핑몰들에 병렬로 여러 요청을 보내야 한다. 비동기 처리를 이용하면, A쇼핑몰에 요청을 보내고 응답이 올 때까지 기다릴 필요 없이 B쇼핑몰에 요청을 보내어 총 처리 시간을 획기적으로 단축시킬 수 있다. 다른 프레임워크들이 비동기 처리를 지원하지 않는 것은 아니지만, JS가 비동기 처리를 가장 간편히 지원하기에 이 프로젝트에 적합하다고 판단하였다. 

***

## Todo-List
- 실제 쇼핑몰 페이지 크롤링
- 정확히 같은 상품을 찾기 위해 상품명을 파싱하는 과정(텍스트 전처리)(LLM을 활용해도 좋을 듯 하다.)
- 한번 크롤링한 상품을 캐싱할 데이터베이스

## AI 활용
나는 초보 개발자이기 때문에, 프로그램을 개발하는 과정에서 구글과 AI의 도움을 많이 받았다. 어느 부분은 AI가 작성해 준 코드를 그대로 활용하기도 했지만, 이번 프로젝트는 학습의 목적이 컸기에 AI는 검색 도구로만 활용하고 최대한 직접 코딩을 하고자 노력했다.

그리고 프로젝트라는 경험 자체도 부족하다. 그래서 Gemini에게 내 아이디어를 간단하게 평가받았고, Brainstorming 기능을 이용해 아이디어를 더 구체화하였다. 그리고 다음으로 진행할 Task를 AI에게 추천받는 방식으로 개발을 진행했다. AI는 지금까지 다음과 같은 순서대로 프로젝트 프로그레스를 정리해주었다. 
1. `manifest.json`에 내가 만들 브라우저 익스텐션 정의하기
2. `content.js`로 쇼핑몰 페이지의 상품명 가져오기
3. `popup.html`과 `popup.js`로 `content.js`로부터 데이터를 받아와 사용자에게 보여지는 UI 작성하기
4. 상품명을 가져와 띄우는 기능이 제대로 작동하는지 로컬 테스트
5. 백엔드 서버 구현과 연결 테스트
6. 실제 검색어 처리 로직 구현


또한 이러한 프로젝트에서 일어나는 일반적인 선택을 알려주기도 하였다. 예를 들면, 이러한 브라우저 익스텐션에  `Bootstrap` 이나 `Font Awesome` 같은 라이브러리를 사용해도 괜찮을지에 대해 고민했는데, Gemini는 기본적으로 브라우저 익스텐션은 가벼워야 한다는 이유로 바닐라 JS를 이용하는 것을 추천했다. `popup.js`와 `content.js`의 기능을 분리하는 이유와 방식 역시 AI의 설명을 통해 이해할 수 있었다.

## 예상되는 난관들
- 가장 걱정되는 것은 백엔드 개발이다. 일단 나는 프론트엔드만 공부해봤기에, 백엔드 개발 자체가 생소하다. 게다가 이 익스텐션의 핵심은 
  > 화면의 요소를 얼마나 **잘 컨트롤**하느냐

  가 아니라 

  > 얼마나 **빠르고 정확하게** 일치하는 상품을 찾아올 수 있느냐 

  이다. 이 프로젝트는 프론트엔드만 배웠고, 아직 데이터 처리나 크롤링을 배우지 않은 나로서는 어려운 도전일 수 밖에 없다. 
- 다양한 쇼핑몰들 (쿠팡, 지마켓, 11번가, 알리익스프레스 등) 에 대하여 상품명을 가져오는 코드(셀렉터)를 알맞게 변형해야 하므로 상당한 노가다가 필요할 것이다.
- 일부 쇼핑몰의 경우 크롤링에 제약이 있을 수 있다. 해당 쇼핑몰의 API를 찾아보거나, 다른 접근 방식을 찾아내야 할 것이다.
